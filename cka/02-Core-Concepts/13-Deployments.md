## Deployments
- A Deployment manages a set of Pods to run an application workload, usually one that doesn't maintain state.
- A Deployment provides declarative updates for Pods and ReplicaSets.
- You describe a desired state in a Deployment, and the Deployment Controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.
- **Pod-template-hash label** The pod-template-hash label is added by the Deployment controller to every ReplicaSet that a Deployment creates or adopts. This label ensures that child ReplicaSets of a Deployment do not overlap. It is generated by hashing the PodTemplate of the ReplicaSet and using the resulting hash as the label value that is added to the ReplicaSet selector, Pod template labels, and in any existing Pods that the ReplicaSet might have.
- Deployment ensures that only a certain number of Pods are down while they are being updated. By default, it ensures that at least 75% of the desired number of Pods are up (25% max unavailable). Deployment also ensures that only a certain number of Pods are created above the desired number of Pods. By default, it ensures that at most 125% of the desired number of Pods are up (25% max surge).
- **Label selector updates** In API version apps/v1, a Deployment's label selector is immutable after it gets created. it means we can not change the deployment's label selector.
- You cannot rollback a paused Deployment until you resume it.

## Use Case
The following are typical use cases for Deployments:
- **Create a Deployment to rollout a ReplicaSet**. The ReplicaSet creates Pods in the background. Check the status of the rollout to see if it succeeds or not.
- **Declare the new state of the Pods** by updating the PodTemplateSpec of the Deployment. A new ReplicaSet is created and the Deployment manages moving the Pods from the old
  ReplicaSet to the new one at a controlled rate. Each new ReplicaSet updates the revision of the Deployment.
- **Rollback to an earlier Deployment revision** if the current state of the Deployment is not stable. Each rollback updates the revision of the Deployment.
- **Scale up the Deployment to facilitate more load.**
- **Pause the rollout of a Deployment** to apply multiple fixes to its PodTemplateSpec and then resume it to start a new rollout.
- **Use the status of the Deployment** as an indicator that a rollout has stuck.
- **Clean up older ReplicaSets** that you don't need anymore.

## Notes
- You must specify an appropriate selector and Pod template labels in a Deployment. Do not overlap labels or selectors with other controllers (including other Deployments and StatefulSets). Kubernetes doesn't stop you from overlapping, and if multiple controllers have overlapping selectors those controllers might conflict and behave unexpectedly.
- A Deployment's rollout is triggered if and only if the Deployment's Pod template (that is, .spec.template) is changed, for example if the labels or container images of the template are updated. Other updates, such as scaling the Deployment, do not trigger a rollout.
- Kubernetes doesn't count terminating Pods when calculating the number of availableReplicas, which must be between replicas - maxUnavailable and replicas + maxSurge. As a result, you might notice that there are more Pods than expected during a rollout, and that the total resources consumed by the Deployment is more than replicas + maxSurge until the terminationGracePeriodSeconds of the terminating Pods expires.
- A Deployment's revision is created when a Deployment's rollout is triggered. This means that the new revision is created if and only if the Deployment's Pod template (.spec.template) is changed, for example if you update the labels or container images of the template. Other updates, such as scaling the Deployment, do not create a Deployment revision, so that you can facilitate simultaneous manual- or auto-scaling. This means that when you roll back to an earlier revision, only the Deployment's Pod template part is rolled back.
- The Deployment controller stops the bad rollout automatically, and stops scaling up the new ReplicaSet. This depends on the rollingUpdate parameters (maxUnavailable specifically) that you have specified. Kubernetes by default sets the value to 25%.
- 
#### Deployment using kubectl
- create the deployment using deployment definition file
  ```
  kubectl create -f https://raw.githubusercontent.com/akshayverma5122/Kubernetes/refs/heads/master/cka/02-Core-Concepts/manifest/deployment-definition.yaml
  ```
- To see the created deployment
  ```
  kubectl get deployment
  ```
- The deployment automatically creates a **`ReplicaSet`**. To see the replicasets
  ```
  kubectl get replicaset
  ```
- The replicasets ultimately creates **`PODs`**. To see the PODs
  ```
  kubectl get pods
  ``` 
- To see the all objects at once
  ```
  kubectl get all
  ```
#### Rolling out the deployment
- Update the deployment to change the image.
  ```
  kubectl set image deployment nginx-deployment  nginx=nginx:1.16.1
  ```
- To see the rollout status of deployment
  ```
  kubectl rollout status deployment nginx-deployment
  ```
#### Rolling back the deployment
- update the wrong container image so that deployment will stuck
  ```
  kubectl set image deployment nginx-deployment nginx=nginx:1.161
  ```
- check the rollout status of deployment
  ```
  kubectl rollout status deployment nginx-deployment
  ```
- Now, deployment will not succeed and we need to rollback the deployment but First, check the revisions of this Deployment.
  ```
  kubectl rollout history deployment nginx-deployment
  kubectl rollout history deployment nginx-deployment --revision=1
  ```
- Now rollback the deployment to previous version or Alternatively, we can rollback to a specific revision by specifying it with --to-revision.
  ```
  kubectl rollout undo deployment nginx-deployment
  kubectl rollout undo deployment nginx-deployment --to-revision=3
  ```
#### Scaling a Deployment
- You can scale a Deployment by using the following command
  ```
  kubectl scale deployment nginx-deployment --replicas=10 -n default
  ```
- if **horizontal Pod autoscaling** is enabled in the cluster then you can set up an autoscaler for your Deployment and choose the minimum and maximum number of Pods you want to run based on the CPU utilization of your existing Pods.
  ```
  kubectl autoscale deployment nginx-deployment --min=5 --max=10 --cpu-percent=80
  ```
#### Proportional scaling
- RollingUpdate Deployments support running multiple versions of an application at the same time. When you or an autoscaler scales a RollingUpdate Deployment that is in the middle of a rollout (either in progress or paused), the Deployment controller balances the additional replicas in the existing active ReplicaSets (ReplicaSets with Pods) in order to mitigate risk. This is called proportional scaling.
- Create the deployment with 10 replicas
  ```
  kubectl create deployment oarm --image=nginx --replicas=10 -n defaul
  ```
- update the new image with nginx1.161 which happens to be unresolvable from inside the cluster.
  ```
  kubectl set image deployment oarm nginx=nginx:1.14.1
  ```
- The image update starts a new rollout with ReplicaSet nginx-deployment-1989198191, but it's blocked due to the maxUnavailable requirement that you mentioned above. Check out the rollout status:
  ```
  kubectl get rs
  ```
- scale the deployment with 15 replicas
  ```
  kubectl scale deploy oarm --replicas=15
  ```
- Then a new scaling request for the Deployment comes along. The autoscaler increments the Deployment replicas to 15. The Deployment controller needs to decide where to add these new 5 replicas. If you weren't using proportional scaling, all 5 of them would be added in the new ReplicaSet. With proportional scaling, you spread the additional replicas across all ReplicaSets. Bigger proportions go to the ReplicaSets with the most replicas and lower proportions go to ReplicaSets with less replicas. Any leftovers are added to the ReplicaSet with the most replicas. ReplicaSets with zero replicas are not scaled up. In our example above, 3 replicas are added to the old ReplicaSet and 2 replicas are added to the new ReplicaSet.
  ```
  kubectl get rs
  ```
- The rollout process should eventually move all replicas to the new ReplicaSet, assuming the new replicas become healthy after executing the below commands.
  ```
  kubectl set image deployment oarm nginx=nginx:1.14.1
  kubectl get rs
  ```
  ## Pausing and Resuming a rollout of a Deployment
- it will allows you to apply multiple fixes in between pausing and resuming the deployment without triggering unnecessary rollouts. First, Create the deployment.
  ```
  kubectl create deployment myapp1 --image=nginx --replicas=3 --port=80 -n default
  ```
- Pause the deployment by running the following command.
  ```
  kubectl rollout pause deployment myapp1 -n default
  ```
- update the image of the Deployment. it will not trigger the rollout of deployment becase it has pause status. check the revision history of deployment for validation. 
  ```
  kubectl set image deployment myapp1 nginx=nginx:1.16.1 -n default
  kubectl rollout history deployment myapp1 -n default
  ```
- We can make as many updates as I want, for example, we update the resources that will be used. it will also not trigger the deployment rollout.
  ```
  kubectl set resources deployment myapp1 -c=nginx --requests=cpu=250m,memory=500Mi --limits=cpu=500m,memory=1Gi -n default
  ```
- Eventually, resume the Deployment rollout and observe a new ReplicaSet coming up with all the new updates
  ```
  kubectl rollout resume deployment myapp1 -n default
  watch kubectl get rs --selector=app=myapp1 -n default
  ```

  
  
  

  
  
  
  
 
  
K8s Reference Docs:
- https://kubernetes.io/docs/concepts/workloads/controllers/deployment/
- https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/
- https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/
- https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/
